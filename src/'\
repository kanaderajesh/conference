#include<Session.h>
Session::Session(int maxtime,Session::sessionType sessionType,const talkPtr_list_type& talkList,const talk_hash_type
& talkHash):sessionMaxTime(maxtime),sessiontype(sessionType),talk_list(talkList),talk_hash(talkHash){
}
void Session::printSessionTalk()
{
	std::cout << "printSessionTalk " << std::endl;
	try{
		for(talkPtr_list_type::const_iterator iter=sessionTalkList.begin();iter!=sessionTalkList.end();iter++)
		{
			std::cout<< (*iter).get()->getDescription() << std::endl;
		}	
	}catch(const std::exception& e){
        std::cout<< e.what() << std::endl;
        throw e;
    }

}
/**************************************************************************
****   Subset sum : Print all subsets with required sum                 ****
****   http://www.edufyme.com/code/?id=45c48cce2e2d7fbdea1afc51c7c6ad26 ****
***************************************************************************/
void Session::printVector(std::vector<int> &v)
{
     std::vector<int> setData;
     for(int i = 0; i<v.size(); i++)
     {
         std::cout<<v[i]<<" ";
         setData.push_back(v[i]);
     }
     std::cout<<std::endl;
     subset_list.push_back(setData);
}
void Session::ss(std::vector<int> &list, int n, std::vector<int> current, int sum)
{
    if( sum == 0 ) { printVector(current); return; }

    if( n == 0 ) return;

    if( list[n-1] <= sum )
    {
         ss(list, n-1, current, sum);
         current.push_back(list[n-1]);
         ss(list, n-1, current, sum-list[n-1]);
    }
    else
    {
        ss(list, n-1, current, sum);
    }
}
int Session::fillUnScheduledTalkDuration(int maxIteration ) 
{
	std::cout<< "iter : " << maxIteration << std::endl;
	try{
		vec_int_type set_of_num,curr;
		int totalTime = 0;	
		int iter = 0;
		for( int cnt = 0; cnt < talk_list.size(); cnt++ ){
			if( !talk_list[cnt].get()->isScheduled() )
			{
			    totalTime += talk_list[cnt].get()->getTalkTime();	
				set_of_num.push_back(talk_list[cnt].get()->getTalkTime());	
				iter++;
				if ( iter == maxIteration || totalTime >= 180 ){
					break;
				}	
					
			}
		}
		for( int i =0 ; i < set_of_num.size() ; i++)
		{
			std::cout << set_of_num[i] << " " ;
		}			
		std::cout<<std::endl;
		ss(set_of_num,iter,curr,180);
		if( subset_list.size() != 0)
		{
			return maxIteration;
		}
		/*		
		else
		{
			return fillUnScheduledTalkDuration(maxIteration+1);	
		}
		*/
	}catch(const std::exception& e){
		std::cout<< e.what() << std::endl;
		throw e;
	}	
}

int Session::getMorningSession(std::vector<int>& vec)
{
	try{
		subset_list.clear();
		std::cout << "no of iteration : " << fillUnScheduledTalkDuration(5)<< std::endl;
		if(subset_list.size() > 0){
			return 0;
		}
		return -1;
	}catch(const std::exception& e){
        std::cout<< e.what() << std::endl;
        throw e;
    }


}
int Session::getFirstTalkWithMatchDurationFromHash(int duration, Session::talk_ptr_type& talkRef ){
	try{
		int indexToLook =0 ;
		switch(duration)
		{
			case 60:
					indexToLook = 0;
					break;
			case 45:
					indexToLook = 1;
					break;
			case 30:
					indexToLook = 2;
					break;
			case 15:
					indexToLook = 3;
					break;
			case 5:
					indexToLook = 4;
					break;
			default:
					indexToLook = 5;
                    break;
		};
	    for(int cnt = 0 ; cnt < talk_hash[indexToLook].size() ; cnt++)
		{	
			if (! talk_hash[indexToLook][cnt].get()->isScheduled()){
				talkRef = talk_hash[indexToLook][cnt];
				return 1;
			}		
		}
		return -1;
	}catch(const std::exception& e){
        std::cout<< e.what() << std::endl;
        throw e;
    }

}
void Session::processMorningSession(){
	try{
			talk_ptr_type talk;
            std::vector<int> vec;
			if(getMorningSession(vec) != -1){
				for( int i = 0; i< subset_list[0].size(); i++)
                {
                    int duration = subset_list[0][i];
                    if (getFirstTalkWithMatchDurationFromHash(duration,talk) != -1 ){
                        talk.get()->markScheduled();
                        sessionTotalTime += talk.get()->getTalkTime();
                        std::cout<< talk.get()->getDescription() << std::endl;
                    }
                }
			}else{
				processEveningSession();
			}
		}catch(const std::exception& e){
        	std::cout<< e.what() << std::endl;
        throw e;
    }
}
void Session::processEveningSession(){
	try{
		std::cout << " sessionMaxTime " << sessionMaxTime << std::endl;
		int remainingTime = sessionMaxTime;
        for(talkPtr_list_type::const_iterator iter=talk_list.begin();iter != talk_list.end();iter++)
        {
        	if(!(*iter).get()->isScheduled() && (*iter).get()->getTalkTime() <= remainingTime ){
        		sessionTotalTime += (*iter).get()->getTalkTime();
				remainingTime -= (*iter).get()->getTalkTime();
        		(*iter).get()->markScheduled();
				std::cout<< (*iter).get()->getDescription() << std::endl;
        	}
        }
		if(sessiontype == Session::MORNING){
			if ( sessionTotalTime == 180

		}	
		std::cout << " sessionTotalTime " << sessionTotalTime << std::endl;
        }catch(const std::exception& e){
            std::cout<< e.what() << std::endl;
        throw e;
    }
}
void Session::addTalk()
{
	try{
			processEveningSession();
			/*	

			if(sessiontype == Session::MORNING){
				processMorningSession();
			}else{
				processEveningSession();
			}
		*/		
	}catch(const std::exception& e){
        std::cout<< e.what() << std::endl;
        throw e;
    }
		
}
